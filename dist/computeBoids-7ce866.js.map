{"version":3,"sources":["webpack:///./src/glslang.ts","webpack:///./src/examples/computeBoids.ts"],"names":["glslang","undefined","glslangModule","import","default","title","description","init","canvas","useWGSL","adapter","navigator","gpu","requestAdapter","device","requestDevice","swapChain","getContext","configureSwapChain","format","renderPipeline","createRenderPipeline","vertexStage","module","createShaderModule","code","wgslShaders","vertex","glslShaders","transform","glsl","compileGLSL","entryPoint","fragmentStage","fragment","primitiveTopology","depthStencilState","depthWriteEnabled","depthCompare","vertexState","vertexBuffers","arrayStride","stepMode","attributes","shaderLocation","offset","colorStates","computePipeline","createComputePipeline","computeStage","compute","renderPassDescriptor","colorAttachments","attachment","loadValue","r","g","b","a","depthStencilAttachment","createTexture","size","width","height","depth","usage","GPUTextureUsage","OUTPUT_ATTACHMENT","createView","depthLoadValue","depthStoreOp","stencilLoadValue","stencilStoreOp","vertexBufferData","Float32Array","verticesBuffer","createBuffer","byteLength","GPUBufferUsage","VERTEX","mappedAtCreation","getMappedRange","set","unmap","simParamData","simParamBuffer","UNIFORM","initialParticleData","numParticles","i","Math","random","particleBuffers","Array","particleBindGroups","STORAGE","createBindGroup","layout","getBindGroupLayout","entries","binding","resource","buffer","t","getCurrentTexture","commandEncoder","createCommandEncoder","passEncoder","beginComputePass","setPipeline","setBindGroup","dispatch","endPass","beginRenderPass","setVertexBuffer","draw","defaultQueue","submit","finish"],"mappings":"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","file":"computeBoids-7ce866.js","sourcesContent":["let glslang = undefined;\nexport default async function() {\n  if (glslang !== undefined) return glslang;\n  // @ts-ignore\n  const glslangModule = await import(/* webpackIgnore: true */ 'https://unpkg.com/@webgpu/glslang@0.0.15/dist/web-devel/glslang.js');\n  glslang = await glslangModule.default();\n  return glslang;\n}\n","import glslangModule from '../glslang';\n\nexport const title = 'Compute Boids';\nexport const description = 'A GPU compute particle simulation that mimics \\\n                            the flocking behavior of birds. A compute shader updates \\\n                            two ping-pong buffers which store particle data. The data \\\n                            is used to draw instanced particles.';\n\nexport async function init(canvas: HTMLCanvasElement, useWGSL: boolean) {\n  const numParticles = 1500;\n\n  const adapter = await navigator.gpu.requestAdapter();\n  const device = await adapter.requestDevice();\n  const glslang = await glslangModule();\n\n  const context = canvas.getContext('gpupresent');\n\n  const swapChain = context.configureSwapChain({\n    device,\n    format: \"bgra8unorm\"\n  });\n\n  const renderPipeline = device.createRenderPipeline({\n    vertexStage: {\n      module: useWGSL\n        ? device.createShaderModule({\n            code: wgslShaders.vertex,\n          })\n        : device.createShaderModule({\n            code: glslShaders.vertex,\n            transform: (glsl) => glslang.compileGLSL(glsl, \"vertex\"),\n          }),\n      entryPoint: \"main\",\n    },\n    fragmentStage: {\n      module: useWGSL\n        ? device.createShaderModule({\n            code: wgslShaders.fragment,\n          })\n        : device.createShaderModule({\n            code: glslShaders.fragment,\n            transform: (glsl) => glslang.compileGLSL(glsl, \"fragment\"),\n          }),\n      entryPoint: \"main\",\n    },\n\n    primitiveTopology: \"triangle-list\",\n\n    depthStencilState: {\n      depthWriteEnabled: true,\n      depthCompare: \"less\",\n      format: \"depth24plus-stencil8\",\n    },\n\n    vertexState: {\n      vertexBuffers: [\n        {\n          // instanced particles buffer\n          arrayStride: 4 * 4,\n          stepMode: \"instance\",\n          attributes: [\n            {\n              // instance position\n              shaderLocation: 0,\n              offset: 0,\n              format: \"float2\",\n            },\n            {\n              // instance velocity\n              shaderLocation: 1,\n              offset: 2 * 4,\n              format: \"float2\",\n            },\n          ],\n        },\n        {\n          // vertex buffer\n          arrayStride: 2 * 4,\n          stepMode: \"vertex\",\n          attributes: [\n            {\n              // vertex positions\n              shaderLocation: 2,\n              offset: 0,\n              format: \"float2\",\n            },\n          ],\n        },\n      ],\n    },\n\n    colorStates: [\n      {\n        format: \"bgra8unorm\",\n      },\n    ],\n  });\n\n  const computePipeline = device.createComputePipeline({\n    computeStage: {\n      module: useWGSL\n        ? device.createShaderModule({\n            code: wgslShaders.compute(numParticles),\n          })\n        : device.createShaderModule({\n            code: glslShaders.compute(numParticles),\n            transform: (glsl) => glslang.compileGLSL(glsl, \"compute\"),\n          }),\n      entryPoint: \"main\",\n    },\n  });\n\n  const depthTexture = device.createTexture({\n    size: { width: canvas.width, height: canvas.height, depth: 1 },\n    format: \"depth24plus-stencil8\",\n    usage: GPUTextureUsage.OUTPUT_ATTACHMENT\n  });\n\n  const renderPassDescriptor: GPURenderPassDescriptor = {\n    colorAttachments: [{\n      attachment: undefined,  // Assigned later\n      loadValue: { r: 0.0, g: 0.0, b: 0.0, a: 1.0 },\n    }],\n    depthStencilAttachment: {\n      attachment: depthTexture.createView(),\n      depthLoadValue: 1.0,\n      depthStoreOp: \"store\",\n      stencilLoadValue: 0,\n      stencilStoreOp: \"store\",\n    }\n  };\n\n  const vertexBufferData = new Float32Array([-0.01, -0.02, 0.01, -0.02, 0.00, 0.02]);\n  const verticesBuffer = device.createBuffer({\n    size: vertexBufferData.byteLength,\n    usage: GPUBufferUsage.VERTEX,\n    mappedAtCreation: true,\n  });\n  new Float32Array(verticesBuffer.getMappedRange()).set(vertexBufferData);\n  verticesBuffer.unmap();\n\n  const simParamData = new Float32Array([\n    0.04,  // deltaT;\n    0.1,   // rule1Distance;\n    0.025, // rule2Distance;\n    0.025, // rule3Distance;\n    0.02,  // rule1Scale;\n    0.05,  // rule2Scale;\n    0.005  // rule3Scale;\n  ]);\n  const simParamBuffer = device.createBuffer({\n    size: simParamData.byteLength,\n    usage: GPUBufferUsage.UNIFORM,\n    mappedAtCreation: true,\n  });\n  new Float32Array(simParamBuffer.getMappedRange()).set(simParamData);\n  simParamBuffer.unmap();\n\n  const initialParticleData = new Float32Array(numParticles * 4);\n  for (let i = 0; i < numParticles; ++i) {\n    initialParticleData[4 * i + 0] = 2 * (Math.random() - 0.5);\n    initialParticleData[4 * i + 1] = 2 * (Math.random() - 0.5);\n    initialParticleData[4 * i + 2] = 2 * (Math.random() - 0.5) * 0.1;\n    initialParticleData[4 * i + 3] = 2 * (Math.random() - 0.5) * 0.1;\n  }\n\n  const particleBuffers: GPUBuffer[] = new Array(2);\n  const particleBindGroups: GPUBindGroup[] = new Array(2);\n  for (let i = 0; i < 2; ++i) {\n    particleBuffers[i] = device.createBuffer({\n      size: initialParticleData.byteLength,\n      usage: GPUBufferUsage.VERTEX | GPUBufferUsage.STORAGE,\n      mappedAtCreation: true,\n    });\n    new Float32Array(particleBuffers[i].getMappedRange()).set(initialParticleData);\n    particleBuffers[i].unmap();\n  }\n\n  for (let i = 0; i < 2; ++i) {\n    particleBindGroups[i] = device.createBindGroup({\n      layout: computePipeline.getBindGroupLayout(0),\n      entries: [{\n        binding: 0,\n        resource: {\n          buffer: simParamBuffer,\n          offset: 0,\n          size: simParamData.byteLength\n        },\n      }, {\n        binding: 1,\n        resource: {\n          buffer: particleBuffers[i],\n          offset: 0,\n          size: initialParticleData.byteLength,\n        },\n      }, {\n        binding: 2,\n        resource: {\n          buffer: particleBuffers[(i + 1) % 2],\n          offset: 0,\n          size: initialParticleData.byteLength,\n        },\n      }],\n    });\n  }\n\n  let t = 0;\n  return function frame() {\n    renderPassDescriptor.colorAttachments[0].attachment = swapChain.getCurrentTexture().createView();\n\n    const commandEncoder = device.createCommandEncoder();\n    {\n      const passEncoder = commandEncoder.beginComputePass();\n      passEncoder.setPipeline(computePipeline);\n      passEncoder.setBindGroup(0, particleBindGroups[t % 2]);\n      passEncoder.dispatch(numParticles);\n      passEncoder.endPass();\n    }\n    {\n      const passEncoder = commandEncoder.beginRenderPass(renderPassDescriptor);\n      passEncoder.setPipeline(renderPipeline);\n      passEncoder.setVertexBuffer(0, particleBuffers[(t + 1) % 2]);\n      passEncoder.setVertexBuffer(1, verticesBuffer);\n      passEncoder.draw(3, numParticles, 0, 0);\n      passEncoder.endPass();\n    }\n    device.defaultQueue.submit([commandEncoder.finish()]);\n\n    ++t;\n  }\n}\n\nexport const glslShaders = {\n  vertex: `#version 450\nlayout(location = 0) in vec2 a_particlePos;\nlayout(location = 1) in vec2 a_particleVel;\nlayout(location = 2) in vec2 a_pos;\nvoid main() {\n  float angle = -atan(a_particleVel.x, a_particleVel.y);\n  vec2 pos = vec2(a_pos.x * cos(angle) - a_pos.y * sin(angle),\n          a_pos.x * sin(angle) + a_pos.y * cos(angle));\n  gl_Position = vec4(pos + a_particlePos, 0, 1);\n}`,\n\n  fragment: `#version 450\nlayout(location = 0) out vec4 fragColor;\nvoid main() {\n  fragColor = vec4(1.0);\n}`,\n\n  compute: (numParticles: number) => `#version 450\nstruct Particle {\n  vec2 pos;\n  vec2 vel;\n};\n\nlayout(std140, set = 0, binding = 0) uniform SimParams {\n  float deltaT;\n  float rule1Distance;\n  float rule2Distance;\n  float rule3Distance;\n  float rule1Scale;\n  float rule2Scale;\n  float rule3Scale;\n} params;\n\nlayout(std140, set = 0, binding = 1) buffer ParticlesA {\n  Particle particles[${numParticles} /* numParticles */];\n} particlesA;\n\nlayout(std140, set = 0, binding = 2) buffer ParticlesB {\n  Particle particles[${numParticles} /* numParticles */];\n} particlesB;\n\nvoid main() {\n  // https://github.com/austinEng/Project6-Vulkan-Flocking/blob/master/data/shaders/computeparticles/particle.comp\n\n  uint index = gl_GlobalInvocationID.x;\n  if (index >= ${numParticles} /* numParticles */) { return; }\n\n  vec2 vPos = particlesA.particles[index].pos;\n  vec2 vVel = particlesA.particles[index].vel;\n\n  vec2 cMass = vec2(0.0, 0.0);\n  vec2 cVel = vec2(0.0, 0.0);\n  vec2 colVel = vec2(0.0, 0.0);\n  int cMassCount = 0;\n  int cVelCount = 0;\n\n  vec2 pos;\n  vec2 vel;\n  for (int i = 0; i < ${numParticles} /* numParticles */; ++i) {\n    if (i == index) { continue; }\n    pos = particlesA.particles[i].pos.xy;\n    vel = particlesA.particles[i].vel.xy;\n\n    if (distance(pos, vPos) < params.rule1Distance) {\n      cMass += pos;\n      cMassCount++;\n    }\n    if (distance(pos, vPos) < params.rule2Distance) {\n      colVel -= (pos - vPos);\n    }\n    if (distance(pos, vPos) < params.rule3Distance) {\n      cVel += vel;\n      cVelCount++;\n    }\n  }\n  if (cMassCount > 0) {\n    cMass = cMass / cMassCount - vPos;\n  }\n  if (cVelCount > 0) {\n    cVel = cVel / cVelCount;\n  }\n\n  vVel += cMass * params.rule1Scale + colVel * params.rule2Scale + cVel * params.rule3Scale;\n\n  // clamp velocity for a more pleasing simulation.\n  vVel = normalize(vVel) * clamp(length(vVel), 0.0, 0.1);\n\n  // kinematic update\n  vPos += vVel * params.deltaT;\n\n  // Wrap around boundary\n  if (vPos.x < -1.0) vPos.x = 1.0;\n  if (vPos.x > 1.0) vPos.x = -1.0;\n  if (vPos.y < -1.0) vPos.y = 1.0;\n  if (vPos.y > 1.0) vPos.y = -1.0;\n\n  particlesB.particles[index].pos = vPos;\n\n  // Write back\n  particlesB.particles[index].vel = vVel;\n}`,\n};\n\nexport const wgslShaders = {\n  vertex: `\n[[location(0)]] var<in> a_particlePos : vec2<f32>;\n[[location(1)]] var<in> a_particleVel : vec2<f32>;\n[[location(2)]] var<in> a_pos : vec2<f32>;\n[[builtin(position)]] var<out> Position : vec4<f32>;\n\n[[stage(vertex)]]\nfn main() -> void {\n  var angle : f32 = -atan2(a_particleVel.x, a_particleVel.y);\n  var pos : vec2<f32> = vec2<f32>(\n      (a_pos.x * cos(angle)) - (a_pos.y * sin(angle)),\n      (a_pos.x * sin(angle)) + (a_pos.y * cos(angle)));\n  Position = vec4<f32>(pos + a_particlePos, 0.0, 1.0);\n  return;\n}\n`,\n\n  fragment: `\n[[location(0)]] var<out> fragColor : vec4<f32>;\n\n[[stage(fragment)]]\nfn main() -> void {\n  fragColor = vec4<f32>(1.0, 1.0, 1.0, 1.0);\n  return;\n}\n`,\n\n  compute: (numParticles: number) => `\n[[block]] struct Particle {\n  [[offset(0)]] pos : vec2<f32>;\n  [[offset(8)]] vel : vec2<f32>;\n};\n[[block]] struct SimParams {\n  [[offset(0)]] deltaT : f32;\n  [[offset(4)]] rule1Distance : f32;\n  [[offset(8)]] rule2Distance : f32;\n  [[offset(12)]] rule3Distance : f32;\n  [[offset(16)]] rule1Scale : f32;\n  [[offset(20)]] rule2Scale : f32;\n  [[offset(24)]] rule3Scale : f32;\n};\n[[block]] struct Particles {\n  [[offset(0)]] particles : [[stride(16)]] array<Particle, ${numParticles}>;\n};\n[[binding(0), set(0)]] var<uniform> params : SimParams;\n[[binding(1), set(0)]] var<storage_buffer> particlesA : Particles;\n[[binding(2), set(0)]] var<storage_buffer> particlesB : Particles;\n[[builtin(global_invocation_id)]] var<in> GlobalInvocationID : vec3<u32>;\n\n# https://github.com/austinEng/Project6-Vulkan-Flocking/blob/master/data/shaders/computeparticles/particle.comp\n[[stage(compute)]]\nfn main() -> void {\n  var index : u32 = GlobalInvocationID.x;\n  if (index >= ${numParticles}) {\n    return;\n  }\n  var vPos : vec2<f32> = particlesA.particles[index].pos;\n  var vVel : vec2<f32> = particlesA.particles[index].vel;\n  var cMass : vec2<f32> = vec2<f32>(0.0, 0.0);\n  var cVel : vec2<f32> = vec2<f32>(0.0, 0.0);\n  var colVel : vec2<f32> = vec2<f32>(0.0, 0.0);\n  var cMassCount : u32 = 0u;\n  var cVelCount : u32 = 0u;\n  var pos : vec2<f32>;\n  var vel : vec2<f32>;\n\n  for (var i : u32 = 0u; i < ${numParticles}u; i = i + 1u) {\n    if (i == index) {\n      continue;\n    }\n\n    pos = particlesA.particles[i].pos.xy;\n    vel = particlesA.particles[i].vel.xy;\n    if (distance(pos, vPos) < params.rule1Distance) {\n      cMass = cMass + pos;\n      cMassCount = cMassCount + 1u;\n    }\n    if (distance(pos, vPos) < params.rule2Distance) {\n      colVel = colVel - (pos - vPos);\n    }\n    if (distance(pos, vPos) < params.rule3Distance) {\n      cVel = cVel + vel;\n      cVelCount = cVelCount + 1u;\n    }\n  }\n  if (cMassCount > 0u) {\n    var temp : f32 = f32(cMassCount);\n    cMass = (cMass / vec2<f32>(temp, temp)) - vPos;\n    # cMass =\n    #   (cMass / vec2<f32>(f32(cMassCount), f32(cMassCount))) - vPos;\n  }\n  if (cVelCount > 0u) {\n    var temp : f32 = f32(cVelCount);\n    cVel = cVel / vec2<f32>(temp, temp);\n    # cVel = cVel / vec2<f32>(f32(cVelCount), f32(cVelCount));\n  }\n  vVel = vVel + (cMass * params.rule1Scale) + (colVel * params.rule2Scale) +\n      (cVel * params.rule3Scale);\n\n  # clamp velocity for a more pleasing simulation\n  vVel = normalize(vVel) * clamp(length(vVel), 0.0, 0.1);\n  # kinematic update\n  vPos = vPos + (vVel * params.deltaT);\n  # Wrap around boundary\n  if (vPos.x < -1.0) {\n    vPos.x = 1.0;\n  }\n  if (vPos.x > 1.0) {\n    vPos.x = -1.0;\n  }\n  if (vPos.y < -1.0) {\n    vPos.y = 1.0;\n  }\n  if (vPos.y > 1.0) {\n    vPos.y = -1.0;\n  }\n  # Write back\n  particlesB.particles[index].pos = vPos;\n  particlesB.particles[index].vel = vVel;\n  return;\n}\n`,\n};\n"],"sourceRoot":""}