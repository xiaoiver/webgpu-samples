{"version":3,"sources":["webpack:///./src/glslang.ts","webpack:///./src/examples/helloTriangle.ts","webpack:///./src/examples/helloTriangleMSAA.ts"],"names":["glslang","undefined","glslangModule","import","default","title","description","init","canvas","useWGSL","adapter","navigator","gpu","requestAdapter","device","requestDevice","swapChain","getContext","configureSwapChain","format","pipeline","createRenderPipeline","vertexStage","module","createShaderModule","code","wgslShaders","vertex","glslShaders","transform","glsl","compileGLSL","entryPoint","fragmentStage","fragment","primitiveTopology","colorStates","commandEncoder","createCommandEncoder","renderPassDescriptor","colorAttachments","attachment","getCurrentTexture","createView","loadValue","r","g","b","a","passEncoder","beginRenderPass","setPipeline","draw","endPass","defaultQueue","submit","finish","sampleCount","createTexture","size","width","height","depth","usage","GPUTextureUsage","OUTPUT_ATTACHMENT","resolveTarget"],"mappings":"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","file":"helloTriangle-54058b.js","sourcesContent":["let glslang = undefined;\nexport default async function() {\n  if (glslang !== undefined) return glslang;\n  // @ts-ignore\n  const glslangModule = await import(/* webpackIgnore: true */ 'https://unpkg.com/@webgpu/glslang@0.0.15/dist/web-devel/glslang.js');\n  glslang = await glslangModule.default();\n  return glslang;\n}\n","import glslangModule from '../glslang';\n\nexport const title = 'Hello Triangle';\nexport const description = 'Shows rendering a basic triangle.';\n\nexport async function init(canvas: HTMLCanvasElement, useWGSL: boolean) {\n  const adapter = await navigator.gpu.requestAdapter();\n  const device = await adapter.requestDevice();\n  const glslang = await glslangModule();\n\n  const context = canvas.getContext(\"gpupresent\");\n\n  const swapChainFormat = \"bgra8unorm\";\n\n  const swapChain = context.configureSwapChain({\n    device,\n    format: swapChainFormat,\n  });\n\n  const pipeline = device.createRenderPipeline({\n    vertexStage: {\n      module: useWGSL\n        ? device.createShaderModule({\n            code: wgslShaders.vertex,\n          })\n        : device.createShaderModule({\n            code: glslShaders.vertex,\n            transform: (glsl) => glslang.compileGLSL(glsl, \"vertex\"),\n          }),\n      entryPoint: \"main\",\n    },\n    fragmentStage: {\n      module: useWGSL\n        ? device.createShaderModule({\n            code: wgslShaders.fragment,\n          })\n        : device.createShaderModule({\n            code: glslShaders.fragment,\n            transform: (glsl) => glslang.compileGLSL(glsl, \"fragment\"),\n          }),\n      entryPoint: \"main\",\n    },\n\n    primitiveTopology: \"triangle-list\",\n\n    colorStates: [\n      {\n        format: swapChainFormat,\n      },\n    ],\n  });\n\n  function frame() {\n    const commandEncoder = device.createCommandEncoder();\n    const textureView = swapChain.getCurrentTexture().createView();\n\n    const renderPassDescriptor: GPURenderPassDescriptor = {\n      colorAttachments: [\n        {\n          attachment: textureView,\n          loadValue: { r: 0.0, g: 0.0, b: 0.0, a: 1.0 },\n        },\n      ],\n    };\n\n    const passEncoder = commandEncoder.beginRenderPass(renderPassDescriptor);\n    passEncoder.setPipeline(pipeline);\n    passEncoder.draw(3, 1, 0, 0);\n    passEncoder.endPass();\n\n    device.defaultQueue.submit([commandEncoder.finish()]);\n  }\n\n  return frame;\n}\n\nexport const glslShaders = {\n  vertex: `#version 450\nconst vec2 pos[3] = vec2[3](vec2(0.0f, 0.5f), vec2(-0.5f, -0.5f), vec2(0.5f, -0.5f));\n\nvoid main() {\n    gl_Position = vec4(pos[gl_VertexIndex], 0.0, 1.0);\n}\n`,\n\n  fragment: `#version 450\n  layout(location = 0) out vec4 outColor;\n\n  void main() {\n      outColor = vec4(1.0, 0.0, 0.0, 1.0);\n  }\n`,\n};\n\nexport const wgslShaders = {\n  vertex: `\nconst pos : array<vec2<f32>, 3> = array<vec2<f32>, 3>(\n    vec2<f32>(0.0, 0.5),\n    vec2<f32>(-0.5, -0.5),\n    vec2<f32>(0.5, -0.5));\n\n[[builtin(position)]] var<out> Position : vec4<f32>;\n[[builtin(vertex_idx)]] var<in> VertexIndex : i32;\n\n[[stage(vertex)]]\nfn main() -> void {\n  Position = vec4<f32>(pos[VertexIndex], 0.0, 1.0);\n  return;\n}\n`,\n  fragment: `\n[[location(0)]] var<out> outColor : vec4<f32>;\n\n[[stage(fragment)]]\nfn main() -> void {\n  outColor = vec4<f32>(1.0, 0.0, 0.0, 1.0);\n  return;\n}\n`,\n};\n","import glslangModule from '../glslang';\n\nexport const title = 'Hello Triangle MSAA';\nexport const description = 'Shows rendering a basic triangle with multisampling.';\n\nexport async function init(canvas: HTMLCanvasElement, useWGSL: boolean) {\n  const adapter = await navigator.gpu.requestAdapter();\n  const device = await adapter.requestDevice();\n  const glslang = await glslangModule();\n\n  const context = canvas.getContext(\"gpupresent\");\n\n  const swapChainFormat = \"bgra8unorm\";\n\n  const swapChain: GPUSwapChain = context.configureSwapChain({\n    device,\n    format: swapChainFormat,\n  });\n\n  const sampleCount = 4;\n\n  const pipeline = device.createRenderPipeline({\n    vertexStage: {\n      module: useWGSL\n        ? device.createShaderModule({\n            code: wgslShaders.vertex,\n          })\n        : device.createShaderModule({\n            code: glslShaders.vertex,\n            transform: (glsl) => glslang.compileGLSL(glsl, \"vertex\"),\n          }),\n      entryPoint: \"main\",\n    },\n    fragmentStage: {\n      module: useWGSL\n        ? device.createShaderModule({\n            code: wgslShaders.fragment,\n          })\n        : device.createShaderModule({\n            code: glslShaders.fragment,\n            transform: (glsl) => glslang.compileGLSL(glsl, \"fragment\"),\n          }),\n      entryPoint: \"main\",\n    },\n\n    primitiveTopology: \"triangle-list\",\n\n    colorStates: [\n      {\n        format: swapChainFormat,\n      },\n    ],\n\n    sampleCount,\n  });\n\n  const texture = device.createTexture({\n    size: {\n      width: canvas.width,\n      height: canvas.height,\n      depth: 1,\n    },\n    sampleCount,\n    format: swapChainFormat,\n    usage: GPUTextureUsage.OUTPUT_ATTACHMENT,\n  });\n  const attachment = texture.createView();\n\n  function frame() {\n    const commandEncoder = device.createCommandEncoder();\n\n    const renderPassDescriptor: GPURenderPassDescriptor = {\n      colorAttachments: [\n        {\n          attachment: attachment,\n          resolveTarget: swapChain.getCurrentTexture().createView(),\n          loadValue: { r: 0.0, g: 0.0, b: 0.0, a: 1.0 },\n        },\n      ],\n    };\n\n    const passEncoder = commandEncoder.beginRenderPass(renderPassDescriptor);\n    passEncoder.setPipeline(pipeline);\n    passEncoder.draw(3, 1, 0, 0);\n    passEncoder.endPass();\n\n    device.defaultQueue.submit([commandEncoder.finish()]);\n  }\n\n  return frame;\n}\n\nexport const glslShaders = {\n  vertex: `#version 450\nconst vec2 pos[3] = vec2[3](vec2(0.0f, 0.5f), vec2(-0.5f, -0.5f), vec2(0.5f, -0.5f));\n\nvoid main() {\n    gl_Position = vec4(pos[gl_VertexIndex], 0.0, 1.0);\n}\n`,\n\n  fragment: `#version 450\n  layout(location = 0) out vec4 outColor;\n\n  void main() {\n      outColor = vec4(1.0, 0.0, 0.0, 1.0);\n  }\n`,\n};\n\nexport const wgslShaders = {\n  vertex: `\nconst pos : array<vec2<f32>, 3> = array<vec2<f32>, 3>(\n    vec2<f32>(0.0, 0.5),\n    vec2<f32>(-0.5, -0.5),\n    vec2<f32>(0.5, -0.5));\n\n[[builtin(position)]] var<out> Position : vec4<f32>;\n[[builtin(vertex_idx)]] var<in> VertexIndex : i32;\n\n[[stage(vertex)]]\nfn main() -> void {\n  Position = vec4<f32>(pos[VertexIndex], 0.0, 1.0);\n  return;\n}\n`,\n  fragment: `\n[[location(0)]] var<out> outColor : vec4<f32>;\n\n[[stage(fragment)]]\nfn main() -> void {\n  outColor = vec4<f32>(1.0, 0.0, 0.0, 1.0);\n  return;\n}\n`,\n};\n"],"sourceRoot":""}