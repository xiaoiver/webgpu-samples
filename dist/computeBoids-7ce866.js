(window.webpackJsonp=window.webpackJsonp||[]).push([[3],{1:function(e,n,t){"use strict";var a=function(e,n,t,a){return new(t||(t=Promise))((function(o,r){function s(e){try{c(a.next(e))}catch(e){r(e)}}function i(e){try{c(a.throw(e))}catch(e){r(e)}}function c(e){var n;e.done?o(e.value):(n=e.value,n instanceof t?n:new t((function(e){e(n)}))).then(s,i)}c((a=a.apply(e,n||[])).next())}))};let o=void 0;n.a=function(){return a(this,void 0,void 0,(function*(){if(void 0!==o)return o;const e=yield import("https://unpkg.com/@webgpu/glslang@0.0.15/dist/web-devel/glslang.js");return o=yield e.default(),o}))}},23:function(e,n,t){"use strict";t.r(n),t.d(n,"title",(function(){return r})),t.d(n,"description",(function(){return s})),t.d(n,"init",(function(){return i})),t.d(n,"glslShaders",(function(){return c})),t.d(n,"wgslShaders",(function(){return l}));var a=t(1),o=function(e,n,t,a){return new(t||(t=Promise))((function(o,r){function s(e){try{c(a.next(e))}catch(e){r(e)}}function i(e){try{c(a.throw(e))}catch(e){r(e)}}function c(e){var n;e.done?o(e.value):(n=e.value,n instanceof t?n:new t((function(e){e(n)}))).then(s,i)}c((a=a.apply(e,n||[])).next())}))};const r="Compute Boids",s="A GPU compute particle simulation that mimics                             the flocking behavior of birds. A compute shader updates                             two ping-pong buffers which store particle data. The data                             is used to draw instanced particles.";function i(e,n){return o(this,void 0,void 0,(function*(){const t=yield navigator.gpu.requestAdapter(),o=yield t.requestDevice(),r=yield Object(a.a)(),s=e.getContext("gpupresent").configureSwapChain({device:o,format:"bgra8unorm"}),i=o.createRenderPipeline({vertexStage:{module:n?o.createShaderModule({code:l.vertex}):o.createShaderModule({code:c.vertex,transform:e=>r.compileGLSL(e,"vertex")}),entryPoint:"main"},fragmentStage:{module:n?o.createShaderModule({code:l.fragment}):o.createShaderModule({code:c.fragment,transform:e=>r.compileGLSL(e,"fragment")}),entryPoint:"main"},primitiveTopology:"triangle-list",depthStencilState:{depthWriteEnabled:!0,depthCompare:"less",format:"depth24plus-stencil8"},vertexState:{vertexBuffers:[{arrayStride:16,stepMode:"instance",attributes:[{shaderLocation:0,offset:0,format:"float2"},{shaderLocation:1,offset:8,format:"float2"}]},{arrayStride:8,stepMode:"vertex",attributes:[{shaderLocation:2,offset:0,format:"float2"}]}]},colorStates:[{format:"bgra8unorm"}]}),u=o.createComputePipeline({computeStage:{module:n?o.createShaderModule({code:l.compute(1500)}):o.createShaderModule({code:c.compute(1500),transform:e=>r.compileGLSL(e,"compute")}),entryPoint:"main"}}),f={colorAttachments:[{attachment:void 0,loadValue:{r:0,g:0,b:0,a:1}}],depthStencilAttachment:{attachment:o.createTexture({size:{width:e.width,height:e.height,depth:1},format:"depth24plus-stencil8",usage:GPUTextureUsage.OUTPUT_ATTACHMENT}).createView(),depthLoadValue:1,depthStoreOp:"store",stencilLoadValue:0,stencilStoreOp:"store"}},p=new Float32Array([-.01,-.02,.01,-.02,0,.02]),v=o.createBuffer({size:p.byteLength,usage:GPUBufferUsage.VERTEX,mappedAtCreation:!0});new Float32Array(v.getMappedRange()).set(p),v.unmap();const d=new Float32Array([.04,.1,.025,.025,.02,.05,.005]),m=o.createBuffer({size:d.byteLength,usage:GPUBufferUsage.UNIFORM,mappedAtCreation:!0});new Float32Array(m.getMappedRange()).set(d),m.unmap();const g=new Float32Array(6e3);for(let e=0;e<1500;++e)g[4*e+0]=2*(Math.random()-.5),g[4*e+1]=2*(Math.random()-.5),g[4*e+2]=2*(Math.random()-.5)*.1,g[4*e+3]=2*(Math.random()-.5)*.1;const P=new Array(2),h=new Array(2);for(let e=0;e<2;++e)P[e]=o.createBuffer({size:g.byteLength,usage:GPUBufferUsage.VERTEX|GPUBufferUsage.STORAGE,mappedAtCreation:!0}),new Float32Array(P[e].getMappedRange()).set(g),P[e].unmap();for(let e=0;e<2;++e)h[e]=o.createBindGroup({layout:u.getBindGroupLayout(0),entries:[{binding:0,resource:{buffer:m,offset:0,size:d.byteLength}},{binding:1,resource:{buffer:P[e],offset:0,size:g.byteLength}},{binding:2,resource:{buffer:P[(e+1)%2],offset:0,size:g.byteLength}}]});let y=0;return function(){f.colorAttachments[0].attachment=s.getCurrentTexture().createView();const e=o.createCommandEncoder();{const n=e.beginComputePass();n.setPipeline(u),n.setBindGroup(0,h[y%2]),n.dispatch(1500),n.endPass()}{const n=e.beginRenderPass(f);n.setPipeline(i),n.setVertexBuffer(0,P[(y+1)%2]),n.setVertexBuffer(1,v),n.draw(3,1500,0,0),n.endPass()}o.defaultQueue.submit([e.finish()]),++y}}))}const c={vertex:"#version 450\nlayout(location = 0) in vec2 a_particlePos;\nlayout(location = 1) in vec2 a_particleVel;\nlayout(location = 2) in vec2 a_pos;\nvoid main() {\n  float angle = -atan(a_particleVel.x, a_particleVel.y);\n  vec2 pos = vec2(a_pos.x * cos(angle) - a_pos.y * sin(angle),\n          a_pos.x * sin(angle) + a_pos.y * cos(angle));\n  gl_Position = vec4(pos + a_particlePos, 0, 1);\n}",fragment:"#version 450\nlayout(location = 0) out vec4 fragColor;\nvoid main() {\n  fragColor = vec4(1.0);\n}",compute:e=>`#version 450\nstruct Particle {\n  vec2 pos;\n  vec2 vel;\n};\n\nlayout(std140, set = 0, binding = 0) uniform SimParams {\n  float deltaT;\n  float rule1Distance;\n  float rule2Distance;\n  float rule3Distance;\n  float rule1Scale;\n  float rule2Scale;\n  float rule3Scale;\n} params;\n\nlayout(std140, set = 0, binding = 1) buffer ParticlesA {\n  Particle particles[${e} /* numParticles */];\n} particlesA;\n\nlayout(std140, set = 0, binding = 2) buffer ParticlesB {\n  Particle particles[${e} /* numParticles */];\n} particlesB;\n\nvoid main() {\n  // https://github.com/austinEng/Project6-Vulkan-Flocking/blob/master/data/shaders/computeparticles/particle.comp\n\n  uint index = gl_GlobalInvocationID.x;\n  if (index >= ${e} /* numParticles */) { return; }\n\n  vec2 vPos = particlesA.particles[index].pos;\n  vec2 vVel = particlesA.particles[index].vel;\n\n  vec2 cMass = vec2(0.0, 0.0);\n  vec2 cVel = vec2(0.0, 0.0);\n  vec2 colVel = vec2(0.0, 0.0);\n  int cMassCount = 0;\n  int cVelCount = 0;\n\n  vec2 pos;\n  vec2 vel;\n  for (int i = 0; i < ${e} /* numParticles */; ++i) {\n    if (i == index) { continue; }\n    pos = particlesA.particles[i].pos.xy;\n    vel = particlesA.particles[i].vel.xy;\n\n    if (distance(pos, vPos) < params.rule1Distance) {\n      cMass += pos;\n      cMassCount++;\n    }\n    if (distance(pos, vPos) < params.rule2Distance) {\n      colVel -= (pos - vPos);\n    }\n    if (distance(pos, vPos) < params.rule3Distance) {\n      cVel += vel;\n      cVelCount++;\n    }\n  }\n  if (cMassCount > 0) {\n    cMass = cMass / cMassCount - vPos;\n  }\n  if (cVelCount > 0) {\n    cVel = cVel / cVelCount;\n  }\n\n  vVel += cMass * params.rule1Scale + colVel * params.rule2Scale + cVel * params.rule3Scale;\n\n  // clamp velocity for a more pleasing simulation.\n  vVel = normalize(vVel) * clamp(length(vVel), 0.0, 0.1);\n\n  // kinematic update\n  vPos += vVel * params.deltaT;\n\n  // Wrap around boundary\n  if (vPos.x < -1.0) vPos.x = 1.0;\n  if (vPos.x > 1.0) vPos.x = -1.0;\n  if (vPos.y < -1.0) vPos.y = 1.0;\n  if (vPos.y > 1.0) vPos.y = -1.0;\n\n  particlesB.particles[index].pos = vPos;\n\n  // Write back\n  particlesB.particles[index].vel = vVel;\n}`},l={vertex:"\n[[location(0)]] var<in> a_particlePos : vec2<f32>;\n[[location(1)]] var<in> a_particleVel : vec2<f32>;\n[[location(2)]] var<in> a_pos : vec2<f32>;\n[[builtin(position)]] var<out> Position : vec4<f32>;\n\n[[stage(vertex)]]\nfn main() -> void {\n  var angle : f32 = -atan2(a_particleVel.x, a_particleVel.y);\n  var pos : vec2<f32> = vec2<f32>(\n      (a_pos.x * cos(angle)) - (a_pos.y * sin(angle)),\n      (a_pos.x * sin(angle)) + (a_pos.y * cos(angle)));\n  Position = vec4<f32>(pos + a_particlePos, 0.0, 1.0);\n  return;\n}\n",fragment:"\n[[location(0)]] var<out> fragColor : vec4<f32>;\n\n[[stage(fragment)]]\nfn main() -> void {\n  fragColor = vec4<f32>(1.0, 1.0, 1.0, 1.0);\n  return;\n}\n",compute:e=>`\n[[block]] struct Particle {\n  [[offset(0)]] pos : vec2<f32>;\n  [[offset(8)]] vel : vec2<f32>;\n};\n[[block]] struct SimParams {\n  [[offset(0)]] deltaT : f32;\n  [[offset(4)]] rule1Distance : f32;\n  [[offset(8)]] rule2Distance : f32;\n  [[offset(12)]] rule3Distance : f32;\n  [[offset(16)]] rule1Scale : f32;\n  [[offset(20)]] rule2Scale : f32;\n  [[offset(24)]] rule3Scale : f32;\n};\n[[block]] struct Particles {\n  [[offset(0)]] particles : [[stride(16)]] array<Particle, ${e}>;\n};\n[[binding(0), set(0)]] var<uniform> params : SimParams;\n[[binding(1), set(0)]] var<storage_buffer> particlesA : Particles;\n[[binding(2), set(0)]] var<storage_buffer> particlesB : Particles;\n[[builtin(global_invocation_id)]] var<in> GlobalInvocationID : vec3<u32>;\n\n# https://github.com/austinEng/Project6-Vulkan-Flocking/blob/master/data/shaders/computeparticles/particle.comp\n[[stage(compute)]]\nfn main() -> void {\n  var index : u32 = GlobalInvocationID.x;\n  if (index >= ${e}) {\n    return;\n  }\n  var vPos : vec2<f32> = particlesA.particles[index].pos;\n  var vVel : vec2<f32> = particlesA.particles[index].vel;\n  var cMass : vec2<f32> = vec2<f32>(0.0, 0.0);\n  var cVel : vec2<f32> = vec2<f32>(0.0, 0.0);\n  var colVel : vec2<f32> = vec2<f32>(0.0, 0.0);\n  var cMassCount : u32 = 0u;\n  var cVelCount : u32 = 0u;\n  var pos : vec2<f32>;\n  var vel : vec2<f32>;\n\n  for (var i : u32 = 0u; i < ${e}u; i = i + 1u) {\n    if (i == index) {\n      continue;\n    }\n\n    pos = particlesA.particles[i].pos.xy;\n    vel = particlesA.particles[i].vel.xy;\n    if (distance(pos, vPos) < params.rule1Distance) {\n      cMass = cMass + pos;\n      cMassCount = cMassCount + 1u;\n    }\n    if (distance(pos, vPos) < params.rule2Distance) {\n      colVel = colVel - (pos - vPos);\n    }\n    if (distance(pos, vPos) < params.rule3Distance) {\n      cVel = cVel + vel;\n      cVelCount = cVelCount + 1u;\n    }\n  }\n  if (cMassCount > 0u) {\n    var temp : f32 = f32(cMassCount);\n    cMass = (cMass / vec2<f32>(temp, temp)) - vPos;\n    # cMass =\n    #   (cMass / vec2<f32>(f32(cMassCount), f32(cMassCount))) - vPos;\n  }\n  if (cVelCount > 0u) {\n    var temp : f32 = f32(cVelCount);\n    cVel = cVel / vec2<f32>(temp, temp);\n    # cVel = cVel / vec2<f32>(f32(cVelCount), f32(cVelCount));\n  }\n  vVel = vVel + (cMass * params.rule1Scale) + (colVel * params.rule2Scale) +\n      (cVel * params.rule3Scale);\n\n  # clamp velocity for a more pleasing simulation\n  vVel = normalize(vVel) * clamp(length(vVel), 0.0, 0.1);\n  # kinematic update\n  vPos = vPos + (vVel * params.deltaT);\n  # Wrap around boundary\n  if (vPos.x < -1.0) {\n    vPos.x = 1.0;\n  }\n  if (vPos.x > 1.0) {\n    vPos.x = -1.0;\n  }\n  if (vPos.y < -1.0) {\n    vPos.y = 1.0;\n  }\n  if (vPos.y > 1.0) {\n    vPos.y = -1.0;\n  }\n  # Write back\n  particlesB.particles[index].pos = vPos;\n  particlesB.particles[index].vel = vVel;\n  return;\n}\n`}}}]);
//# sourceMappingURL=computeBoids-7ce866.js.map